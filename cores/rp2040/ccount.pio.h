// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------ //
// ccount //
// ------ //

#define ccount_wrap_target 0
#define ccount_wrap 1

static const uint16_t ccount_program_instructions[] = {
    //     .wrap_target
    0x0040, //  0: jmp    x--, 0
    0x0080, //  1: jmp    y--, 0
    //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program ccount_program = {
    .instructions = ccount_program_instructions,
    .length = 2,
    .origin = -1,
};

static inline pio_sm_config ccount_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + ccount_wrap_target, offset + ccount_wrap);
    return c;
}

static inline void ccount_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = ccount_program_get_default_config(offset);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_exec(pio, sm, pio_encode_set(pio_x, 0));
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, 0));
}
static inline uint64_t ccount_read(PIO pio, uint sm) {
    static uint64_t extra = 0;
    // Guard against having the epoch rollover while we're reading the time.
    // If epoch2 != epoch1, we looped in middle and get new LSW
    pio_sm_exec(pio, sm, pio_encode_mov(pio_isr, pio_y));
    pio_sm_exec(pio, sm, pio_encode_push(false, false));
    pio_sm_exec(pio, sm, pio_encode_mov(pio_isr, pio_x));
    pio_sm_exec(pio, sm, pio_encode_push(false, false));
    pio_sm_exec(pio, sm, pio_encode_mov(pio_isr, pio_y));
    pio_sm_exec(pio, sm, pio_encode_push(false, false));
    pio_sm_exec(pio, sm, pio_encode_mov(pio_isr, pio_x));
    pio_sm_exec(pio, sm, pio_encode_push(false, false));
    extra += 8;
    uint32_t y1 = -((int)pio_sm_get_blocking(pio, sm));
    uint32_t x1 = -((int)pio_sm_get_blocking(pio, sm));
    uint32_t y2 = -((int)pio_sm_get_blocking(pio, sm));
    uint32_t x2 = -((int)pio_sm_get_blocking(pio, sm));
    uint64_t val;
    if (y2 != y1) {
        val = ((((uint64_t)y2) << 32LL) | x2) + y2 /* adjust for missed cycle every epoch increment */;
    } else {
        val = ((((uint64_t)y1) << 32LL) | x1) + y1 /* adjust for missed cycle every epoch increment */;
    }
    return val + extra;
}

#endif

